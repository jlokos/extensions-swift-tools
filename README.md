# Swift for Raycast Extensions

This Swift Package contains code generation macros and plugins to build a communication channel between [Raycast](https://raycast.com)'s React extensions and Swift native code. Basically, it lets you import Swift code into your Raycast extension in order to:
- leverage native macOS APIs that might not be exposed to TS/JS, or
- use Swift for targeted sections of your extension, letting you use all Swift language features (such as result builders, async/await, generics/existentials, etc.), or
- compartmentalize your extension into client-facing code (react) and system code (swift).

### Requirements

- Xcode.

  Xcode needs to be installed in your system. We are hoping to not need Xcode in the future and use the pure Swift toolchain, alas we are not there yet. Please notice, you don't need to write the swift code in Xcode, you can use any other editor such as VSCode, Sublime, or Nova.


## Using the Package

1. Create (or fork) a Raycast extension.

    If you don't know how, check out [this guide](https://developers.raycast.com/basics/create-your-first-extension).

2. Create a Swift executable target in the folder of your Raycast extension.

   <p>You can create the target in any of the following ways:
   <details><summary>using Xcode, or</summary>
   <p></p>
   <ul>
   <li>Open Xcode</li>
   <li><code>File > New > Package...</code> to create a new Swift package</li>
   <li>Select `Executable`</li>
   <li>Select the place within the Raycast extension package you want</li>
   <li>Untick the "Create Git repository on my Mac"
     <p>I like to put it in a `swift` folder next to the existing `src` folder.</p>
   </li>
   <li>Delete the <code>main.swift</code> file autogenerated by Xcode.
     <p>This file is reserved for the Raycast plugins generating the TypeScript interface.</p>
   </li>

    ![Create a new package](./docs/new-package.png)
    ![New executable package](./docs/new-executable-package.png)
   </p>
   </details>
   <details><summary>using the <code>swift package</code> command in the terminal or VSCode.</summary>
   <p></p>
   <ul>
   <li>Run <code>swift package init --type executable --name CustomName</code> in the Raycast extension folder.
   <p>In the previous command of code <code>CustomName</code> references the name for the Swift Package. You can name this whatever you want.</p>
   </li>
   <li>Delete the <code>main.swift</code> file autogenerated by <code>swift package</code>.
     <p>This file is reserved for the Raycast plugins generating the TypeScript interface.</p>
   </li>
   </ul>
   </details>
   </p>

   > You shouldn't have a `main.swift` file in your project nor a structure marked with `@main`. These are reserved for the Swift-to-TypeScript plugins.

3. Modify the `Package.swift` file to include the necessary macros and build plugins.

    ```diff
    // swift-tools-version: 5.9

    import PackageDescription

    let package = Package(
        name: "CustomName",
    +    platforms: [
    +      .macOS(.v12)
    +    ],
    +    dependencies: [
    +      .package(url: "https://github.com/raycast/extensions-swift-tools", from: "1.0.0")
    +    ],
        targets: [
          .executableTarget(
            name: "CustomName",
    +       dependencies: [
    +         .product(name: "RaycastSwiftMacros", package: "extensions-swift-tools"),
    +         .product(name: "RaycastSwiftPlugin", package: "extensions-swift-tools"),
    +         .product(name: "RaycastTypeScriptPlugin", package: "extensions-swift-tools"),
    +       ]
          ),
        ]
    )
    ```

4. Import `RaycastSwiftMacros` in your Swift file.

   ```swift
   import RaycastSwiftMacros
   ```

5. Write global Swift functions and mark them with the `@raycast` attribute.

   Global functions marked with `@raycast` are exported to TypeScript. These functions can have any number of parameters or one or no return types. Likewise, the function can be asynchronous (`async`) or throw errors (`throws`). The only restrictions are:
   - Parameters must conform to `Decodable`.
   - The return type (if any) must conform to `Encodable`.
   - Variadic parameters and value packs are not supported.
   - Only global functions will be exported. Methods or functions within `struct`s or `enum`s won't be exported.

   ```swift
   @raycast func greet(name: String, isFormal: Bool) -> String {
    let address = isFormal ? "Mr/Ms" : ""
    return "Hello \(address) \(name)! How are you?"
   }
   ```

   Custom types can be received as parameters or returned by the function. You just need to be sure for the type to conform to `Codable`.

   ```swift
   @raycast func pickColor(name: String) throws -> Color {
     switch name {
     case "red": Color(red: 1, green: 0, blue: 0)
     case "green": Color(red: 0, green: 1, blue: 0)
     case "blue": Color(red: 0, green: 0, blue: 1)
     default: throw Color.Error.unsupportedColor
     }
   }

   struct Color: Encodable {
     let red: Float
     let green: Float
     let blue: Float

     enum Error: Swift.Error {
       case unsupportedColor
     }
   }
   ```
